# 领域驱动设计DDD

## 领域驱动设计的原则和实践

### 什么是领域驱动设计？

- 目标

	- 理解领域驱动设计

		- 原则
		- 实践
		- 模式

	- 分析问题空间的重要性
	- 维护软件的重要技能

		- 合作
		- 交流
		- 上下文

- 复杂领域问题带来的挑战

	- 大泥球架构的问题

		- 杂乱无序
		- 面条式的代码
		- 可以工作，但是不明所以

	- 软件复杂的原因

		- 代码实现和业务分析缺乏共同语言

			- 代码没有展现业务意图
			- 分析模型和最终代码没有保持一致

				- 实际操作上可能没有分析模型，得到需求后直接写代码

			- 代码难以阅读和维护

		- 缺乏组织

			- 混乱的代码影响项目进度
			- 容易产生bug

		- 问题域分析不足

			- 问题域是什么？

				- 软件要解决的问题
				- 业务专家和工程师的共识
				- 示例

					- 记录病人治疗的软件

						- 医疗行业专业术语
						- 不同部门如何看病人
						- 医生需要收集什么信息
						- 医生用这些信息做什么

			- 分析问题域为何能降低复杂度？

				- 领域驱动的战略模式，分割解决方案

					- 提炼问题域，找出问题的重点，拆分成更小的问题域
					- 创建模型解决领域问题
					- 使用共同语言完成建模协作
					- 消除模型中的歧义和问题
					- 区分上下文之间的关系

				- 领域驱动的战术模式，实现领域

					- 问题空间
					- 解决空间

- 设计原则和实践

	- 专注于主要领域

		- 软件的价值所在
		- 团队成员必须理解

	- 通过合作学习

		- 业务专家和开发人员互相学习

	- 通过探索和实验构建模型
	- 交流

		- 达成交流的基础：共同语言

	- 理解模型的适用范围
	- 持续改善模型

- 常见的错误观念

	- 战术模式是DDD的关键
	- DDD是一个框架
	- DDD是银弹

### 提炼问题域

- 目标

	- 掌握提炼问题域的方法

- 方法

	- 知识消化和交流

		- 角色

			- 从使用场景开始
			- 业务专家
			- 开发团队

		- 使用共同语言达成共识

			- 共同语言

				- 各方都能理解
				- 明确
				- 描述问题和编程实现时都能使用

		- 理解领域知识

			- 达到用简单术语描述问题

		- 重视业务分析
		- 持续提炼

	- 通过领域专家获得领域认实

		- 领域专家

			- 构建领域模型满足业务和程序的需求

		- 业务需求方

			- 注重需要需要实现得功能

		- 深入理解业务
		- 和领域专家互动

	- 对知识进行提炼压缩

		- 专注于有趣的部分
		- 从使用场景开始
		- 问有用的问题
		- 想法可视化

			- 使用简单图表
			- uml语言
			- 类职责交流卡片

				- 类名
				- 类职责
				- 关联的和实现其目的所需要的类

			- 定义模型名字

		- 行为驱动开发，BDD 

			- 专注于软件行为，软件需要做什么
			- Given
			- When
			- Then

		- 快速形成原型

	- 查看已经存在的模型

		- 理解意图

			- 深入理解用户需求，用户可能基于当前系统提出需求，而不是真正需求

		- 活动风暴

			- 帮助快速理解领域问题
			- 开发团队：提问题
			- 领域专家：回答问题

		- 影响映射，分析需求带来的影响

			- 从整体考虑需求带来的影响

				- 业绩收益
				- 系统影响

			- 提出自己的想法和建议

		- 理解业务模型

			- 使用业务模型卡片：Business Model Canvas

### 专注于主要领域

- 目标

	- 理解拆分领域问题的重要性
	- 如何找出并专注于核心领域
	- 如何实现通用领域
	- 合理设计的重要性，区分主次

- 问题

	- 为什么问题域会变糟糕？

		- 系统越大，越复杂，不是所有功能都一样重要

- 如何找出核心领域

	- 什么是核心领域

		- 系统最有价值的部分

	- 从长远的角度看需求

	  用户会想要一匹更快的马

	- 分析领域问题时尽量不要考虑技术细节
	- 拆分领域问题

		- 核心领域

			- 哪一部分决定产品的成败
			- 把核心领域当初产品

		- 通用领域

			- 通用业务的领域

				- 发送邮件服务

		- 支持领域

			- 支持核心领域

- 通过子领域合作形成解决方案
- 不是所有领域都同等重要

	- 区分领域边界
	- 核心领域不一定一开始就达到完美
	- 新建领域而不要尝试代替遗留领域

### 模型驱动设计

- 目标

	- 什么是领域模型
	- 理解通用语言的重要性
	- 如何用通用语言改善沟通和协作
	- 正确的应用来领域驱动设计
	- 如果创建有效的模型
	- 使用通用语言绑定分析模型和代码模型

- 领域模型

	- 领域和领域模型的区别

		- 领域

			- 需要解决的问题
			- 现实问题

		- 领域模型

			- 问题域的抽象
			- 用视图表示的代码实现
			- 帮助解决当前问题
			- 不涉及技术细节

	- 分析模型

		- 描述系统模型的集合
		- 帮助理解问题领域
		- 不是技术实现的蓝图

	- 代码模型

		- 代码模型是领域模型的重要表达
		- 和业务同步

- 模型驱动设计

	- 将分析模型和代码实现绑定的过程
	- 注重实现
	- 前期设计的挑战

		- 代码实现和分析模型脱钩
		- 要求全团队进行合作
		- 团队信息要同步

	- 如何实现模型驱动设计

		- 使用通用语言绑定分析模型和代码模型
		- 基于通用语言交流合作

			- 开发人员

				- 技术抽象
				- 设计模式
				- 设计原则
				- 考虑领域术语和概念

			- 领域专家

				- 业务处理
				- 工作流

		- 通过示例来优化通用语言
		- 让领域专家专注于问题而非提供解决方案
		- 优化通用语言

			- 确保语言一致，领域专家和开发人员都能理解
			- 和领域专家确术语表
			- 维持同一个事务只有一个术语
			- 尽量避免通用词语

				- service
				- manager
				- policy

			- 尽量避免使用技术领域专业术语

				- 设计模式

			- 良好的命名
			- 根据通用语言命名例外
			- 通用语言要有语义性

	- 什么时候使用模型驱动设计

		- 简单问题可以不用模型化
		- 专注于核心问题

	- 如何高效创建领域模型

		- 专注于核心领域

			- 模型数据结构
			- 有什么操作

		- 不要让真相成为榜样

			- 领域模型是对现实的抽象而非镜像

		- 仅为相关内容建模
		- 模型只是为当时需求建模，与业务保持同步
		- 明确专用术语
		- 合理抽象

			- 通过领域即可理解领域概念，不必深入代码
			- 抽象行为不是实现

		- 尽早用代码实现模型
		- 尽可能想更多实现方案

### 领域模型实现模式

- 目标

	- 理解领域层的作用
	- 掌握实现领域模型的模式
	- 如何选择正确的设计模式

- 领域层

	- 定义

		- 包含领域模型部分的代码

	- 特点

		- 讲领域模型的负责性和应用程序的技术复杂性隔离
		- 确保基础设施不会渗入业务问题

			- 基础设施

				- 事务管理
				- 持久化

	- 实现模式

		- 领域模型

			- 是对象

				- 行为
				- 数据

			- 前提条件

				- 没有数据库，不需要持久化

			- 从代码模型开始，而非数据模型

				- 和数据模型驱动相反

		- 交易脚本

			- 过程化
			- 适用于没有业务逻辑或业务逻辑较少

		- 表模型

			- 映射到数据库

		- 贫血模型

			- 领域对象仅仅是数据传输对象
			- 领域服务处理业务逻辑
			- 适用于没有业务逻辑或业务逻辑较少

### 通过上下文边界维护领域的完整性

- 目标

	- 理解单一模型带来的挑战
	- 理解上下文边界的重要性
	- 掌握找出上下文边界的方法
	- 保护合谐领域的完整性
	- 掌握使用上下文边界的条件

- 为什们要有上下文边界

	- 单一模型带来的挑战

		- 业务变更，模型会变得复杂
		- 多个团队共用一个模型
		- 模型语言带来歧义。同一术语在不同模型中意义可能不一样
		- 不同领域有不同的适用范围，单一模型职责太多

	- 区分模型边界，可降低复杂度
	- 领域模型不是企业模型

- 什么是上下分边界

	- 定义领域的适用范围

		- 领域用来做什么
		- 哪些范围需要保持一致
		- 哪些部分需要忽略

- 划分上下文边界

	- 根据技术划分
	- 根据业务划分
	- 影响上下文边界的因素

		- 领域中术语和概念的歧义
		- 与子领域和业务保持一致
		- 团队组织和物理位置
		- 遗留代码
		- 第三方集成

	- 方法

		- 定义语言边界

			- 与领域专家交谈时，确保上下文明确
			- 如果一个概念在同一个模型里有不同意义，考虑拆分成多个上下文

		- 与业务能力保持一致
		- 为团队创建上下文
		- 保持团队间的交流

- 子领域和上下文边界的区别

	- 子领域

		- 区分应用的重要部分
		- 提炼问题域，降低复杂度

	- 上下文边界

		- 用来实现模型边界的具体技术1
		- 存在于解决域

- 建议

	- 团队协作时，确保成员都明白领域上下文
	- 把上下分边界当作国界

### 映射上下文

- 目标

	- 理解上下文映射在战略设计中的重要性
	- 理解模型在上下文边界中的关系
	- 掌握团队及上下文之间的组织关系模式
	- 如何高效传递上下文映射

- 现实的映射

	- 特点

		- 确保系统各个上下文的边界定义清晰
		- 每个团队都能理解其中的关系
		- 不是详细的文档
		- 足够简单

	- 技术现实

		- 强调上下文之间的整合
		- 技术如何影响应用整合
		- 应用的当前状态
		- 各个上下文之间的联络点以及数据的流动
		- 和代码保持同步

	- 组织现实

		- 团队和团队，人和人之间的关系

- 识别有界上下文之间的关系

	- 反腐层

		- 什么是反腐层

			- 隔离层。类似适配器

				- 内部上下文
				- 中间接口
				- 外部上下文

		- 适用场景

			- 和其他系统通信
			- 本系统内不同领域或者有歧义的相同领域
			- 其他业务可能将现有模型腐化

	- 共享内核

		- 适用场景

			- 有相同的领域逻辑

				- 

	- 开放服务

		- 将共同逻辑做成开放接口，封装，供其他服务使用

	- 服务分开

		- 如果集成服务比较麻烦，可以将服务分开
		- 用户界面或手动流程进行整合

### 应用架构

- 目标

	- 应用架构如何保持领域模型的完整性
	- 应用架构有界上下文的区别
	- 应用服务的角色和职责
	- 如何支持多客户端

- 应用架构

	- 分清应用层序的层次

		- 将技术复杂度和领域复杂度分开
		- 展现UI
		- 持久化
		- 领域逻辑

	- 六边形架构

		- 
		- 底层定义接口，由上层实现

	- 依赖倒置

		- 

	- 领域层

		- 不依赖其他层

	- 应用服务层

		- 应用的使用场景和行为
		- 抽象程度高于领域层，粗粒度的抽象
		- 领域层的客户端
		- 集成其他资源，外部资源要适应接口

			- 从数据源恢复数据1
			- 持久化领域模型状态
			- 与系统其他部分通信

		- 可以作为反腐层

	- 基础设施层

		- 具体实现
		- 日志
		- 安全
		- 通知
		- 其他基础逻辑

	- 层之间的通信

		- 不要通过领域模型通信
		- 通过DTOS(data transfer objects)进行通信
		- 高层必须通过适应低层详消息类型来与底层进行通信

	- 测试分层

		- 可以通过mock其他依赖来进行测试

	- 不要在有界上下文之间共享数据结构

		- 有界上下文有自己独立的数据库

	- 和有界上下文的区别

		- 应用架构可以集成多个有界上下文

- 应用服务：将所有工作委托给该层

	- 只包含应用逻辑

		- 安全
		- 事务管理
		- 和其他服务通信

			- 邮件
			- web服务

	- 领域层客户端
	- 基于接口提供服务
	- 应用逻辑和领域逻辑的区别

		- 应用逻辑

			- 满足业务用例所需的工作流程步骤

				- 校验输入数据
				- 从数据库中得领域对象
				- 将数据转为领域层所需数据
				- 完成业务逻辑

			- 委派领域服务和协调基础设施服务
			- 不做业务逻辑，但是知道给谁做
			- 与技术实现无关

		- 领域逻辑

			- 只解决领域问题

	- 定义和公开功能

		- 客户端适配应用服务，而非应用服务适配客户端

	- 协调业务用例

		- 代表使用场景，而非增删改查

	- 领域层实现具体细节

- 客户端

	- 展现系统的能力
	- 服务应该忽略客户端的功能
	- 客户端要适配服务端Api

### 实践领域驱动设计常见问题

- 目标

	- 理解为什么领域驱动设计不仅仅是写代码
	- 避免过分强调战术模式
	- 为什么错误使用领域驱动设计会让问题变复杂
	- 理解战术设计，合作及交流的重要性
	- 明白专注于核心领域的重要性
	- 理解领域专家的重要性
	- 避免领域驱动设计中的反模式

- 领域驱动设计适用场景

	- 适用于复杂的问题

- 过分强调战术重要性的问题

	- 技术人员专注于写代码忽略业务
	- 所有有界上下分都使用同样的架构
	- 追求战术模式的完美
	- 错把基础构建模块当作DDD的价值，忽略其他部分
	- 专注于代码而不DDD的原则

- 忽略DDD重要的部分：合作，交流以及上下文

	- 低估上下文的重要性
	- 不创建UL导致歧义和误解
	- 缺乏合作设计出依赖技术的解决方案

- 花太多时间在不重要的部分
- 简单问题复杂化

	- 将领域驱动设计应用于琐碎的领域，几乎没有业务期望
	- 忽略crud作为反模式，简单问题可以直接crud
	- 将领域模型模式应用岛所有上下文中

- 应用领域驱动设计的代价

	- 资源
	- 时间

### 应用领域驱动设计原则，实践和模式

- 目标

	- 怎样推销领域驱动设计
	- 将领域驱动设计原则和实践应用到项目中
	- 理解探索和实验在寻找有用模型中的作用
	- 为什么避免歧义能有效提高建模的效率
	- 解决问题时消除技术的复杂性
	- 为什么不需要当心完美的领域模型
	- 怎样知道自己时在做正确的事

- 推销领域驱动设计

	- 团队要求

		- 渴望学习
		- 积极充满激情
		- 熟练
		- 有领域专家

	- 业务要求

		- 复杂且不平凡的业务

	- 方法要求

		- 持续迭代

	- 培养团队

		- 技术不是解决方案，而不是实现细节
		- 解决问题是通过和领域专家合作产生有用模型

	- 和业务需求方交流

- 应用领域驱动设计原则

	- 从简单问题开始，直到熟练
	- 理解愿景

		- 产品的商业目的
		- 产品会带来什么价值
		- 产品为什么会成功
		- 和之前存在的产品有什么区别

	- 捕获所需行为

		- 应用行为驱动设计
		- 需要的行为

			- 使用场景
			- 输入
			- 输出

		- 为什么需要这些行为，什么时候需要
		- 提炼问题空间
		- 专注于重要部分

	- 了解项目的真是性

		- 进行上下文映射
		- 找出受问题域影响模型

			- 画出它们的上下文
			- 为它们命名
			- 谁该为它们负责

		- 绘制集成点和集成方法
		- 映射交换的数据和拥有者
		- 标记出上下文之间的关系
		- 重复上面步骤，直到完全理解

	- 模型化解决方案

		- 前提要求

			- 领域是否足够复杂或者有复杂的子领域
			- 对业务是否重要且有高期待
			- 是否有领域专家参与
			- 团队充满激情并且聪明

		- 不是所有问题都一样重要
		- 吸引领域专家参与
		- 根据具体方案选择行为和模型
		- 和领域专家在最有趣的部分合作
		- 用UL解决歧义
		- 扔掉第一个和第二个模型
		- 在代码中实现模型
		- 创建领域模型

			- 迭代过程
			- 和领域问题相关：解决领域问题
			- 富有表达力：自解释性

				- 为什么这么做
				- 在做什么

		- 保持代码简单，普通
		- 开拓安全领域

			- 处理遗留代码时，将遗留代码隔离

		- 尽快尽早集成模型
		- 非技术层面的重构
		- 分解解决域

	- 探索和实验

		- 改变假设
		- 建模是一个持续的过程
		- 没有错误的模型
		- 发现辅组代码

- 让不明确的变得明确

	- 处理歧义
	- 为事物命名

- 首先解决问题，其次才是技术实现

	- 不要尝试解决所有问题

## 通过战略模式在上下文之间交流

### 集成有界上下文

- 目标

	- 如何在分布式系统中集成有界上下文
	- 构建分布式系统的基本挑战
	- 理解面向服务架构如何帮助构建低耦合的有界上下文和独立团队
	- 通过响应式DDD来实现非技术性需求

- 怎样集成有界上下文

	- 有界上下文是独立的，应该互不影响
	- 在代码层面上集成有界上下文的挑战

		- 解决方案中存在多个有界上下文
		- 通过命名空间或项目

			- 一个项目的改动会影响到其他项目

		- 通过数据库集成

			- 共享数据结构，改变数据结构会改变持有该结构的上下文
			- 容易产生歧义
			- 破环单一职责原则

		- 多个团队在一个代码库上工作

			- 影响协作

		- 模糊模型

			- 依赖混乱
			- 耦合度高

	- 使用物理隔离强制获得干净模型

		- 独立代码库
		- 独立数据库
		- 独立开发团队

	- 集成遗留系统

		- 使用气泡上下分隔离遗留项目

			- 遗留项目
			- 现有项目

		- 自主的气泡上下文

			- 有自己的数据源
			- 可以独立于遗留项目运行

		- 把遗留项目做成服务

- 集成分布式有界上下文

	- 策略

		- 更注重非功能性需求

	- 数据库集成
	- 水平文件集成
	- 远程过程调用(RPC)
	- 消息
	- REST服务

- 分布式系统执行领域驱动设计的挑战

	- RPC的问题

		- 难以做到有弹性

			- 网络请求不稳定

		- 扩展成本更高
		- 产生高耦合

			- 逻辑耦合
			- 时间耦合

	- 分布式事务影响扩展性和可靠性

		- 有界上下文没必要保持一致
		- 保持最终一致

- 事件驱动下反应式领域驱动设计

	- 消息驱动

### 通过消息集成

- 目标

	- 通过异步消息来集成有界上下文
	- 为领域中的重要事件设计和建筑消息系统
	- 理解消息框架如何工作
	- 创建架构示意图
	- 解释命令和事件的区别
	- 行业标准消息的第模式的理论和实例
	- 处理最终一致
	- 监控消息系统中的错误
	- 监控消息系统中的服务级别协议

- 消息基础

	- 消息总线

		- 所有组件都只和消息总线关联

	- 可靠的消息传递

		- 模式

			- 至少一次
			- 最多一次
			- 仅一次

	- 存储转发

		-  保证消息传输的可靠性

	- 指令和事件

		- 指令

			- 触发执行指定的事务
			- 发送方知道接收方如何处理
			- 只能被一个接收者处理

		- 事件

			- 发生了某事的信号
			- 发送方不知道接收方如何处理
			- 可以被多个接收者处理

	- 最终一致

- 实践：基因消息构建一个在线购物网站 

	- 系统设计

		- 领域驱动域设计
		- 组件示意图

			- 有界上下文的工作流程
			- 

		- 容器示意图

			- 应用如何组织
			- 技术选型
			- 通信协议
			- 

		- 架构演进

	- 通过web应用传递指令

		- 使用vue创建搭建前端

	- 处理指令和事件
	- 创建消息网关

		- 通过消息网关提供容错率
		- 控制消息重试

	- 保持最终一致

		- 处理不一致
		- 回滚倒新状态

	- 有界上下文只存储本地所需的数据
	- 通过UI集成所有

		- 业务组件需要他们自己的api

	- 建议

		- 内部有界上下文的通信使用消息
		- 和外部不稳定的通信使用消息网关包装，来提高可靠性
		- 不同上下文可以使用不同技术实现
		- 有界上下文之间不共享数据库

### 通过HTTP和RPC来集成

- 目标

	- 掌握HTTP集成有界上下文的方式
	- 了解REST协议
	- 理解HTTP和RPC的特点及适用场景
	- 如何提高容错率
	- 如何解耦

- 为什么使用HTTP

	- 平台解耦，不依赖特定平台技术
	- 所有人都知道HTTP
	- 可使用的工具多
	- 自给自足的API

- RPC，远程进程调用

	- SOAP，简单对象访问协议

- REST

	- 资源
	- 超媒体
	- 无状态
	- 动词

		- GET
		- POST
		- PUT
		- DELETE

	- 状态码
	- 请求头

## 通过战术模式高效创建领域模型

### 领域驱动设计的构建模块

- 目标

	- 理解战术模式在领域驱动设计中的作用
	- 理解领域驱动设计的构建模块
	- 鸟瞰生命周期模式
	- 了解新兴的事件源和领域事件模式

- 战术模式

	- 基于面向对象
	- 作用

		- 管理领域模型
		- 确保领域行为清晰

- 构建模块

	- Entities(实体)

		- 基于唯一标志符号构建而非属性

	- Value Objects(值对象)

		- 基于特征属性
		- 不可变

	- 领域服务

		- 封装Entities和Value Object中没有的逻辑和概念

	- 模块

		- 分解领域模型，方便管理

- 生命周期管理策略

	- Aggregates(聚合体)

		- 聚合分类管理

	- Factories（工厂）
	- Repostories(仓储）

- 新兴模式

	- 领域事件

### Value Object 值对象

- 目标

	- 掌握值对象及其使用场景
	- 了解持久化值对象的技术

- 什么是值对象

	- 用来描述实体属性的的对象
	- 没有唯一性标志符号
	- 不可变对象
	- 多用于组合

- 什么时候使用值对象

	- 代表描述性，少身份的概念
	- 增强说明性

		- 基本类型和字符串不具明确概念
		- 基本类型和字符串没有丰富的行为

	- 定义独特属性

		- 弱身份属性
		- 基于属性相等
		- 行为丰富
		- 高内聚
		- 不可变
		- 用户组合
		- 自验证
		- 良好的可测试性

- 常用建模模式

	- 静态工厂方法
	- 微型类型

		- 包裹语义强的类型的类型，更具语义性

	- 慎用集合

- 持久化

	- NoSQL
	- SQL

		- 水平非规范化

			- 创建持久化模式

				- 比如用toString

			- 持节化会属性值
			- 加载时反序列化解析

		- 按SQL规范分离到表中

### Entities实体

- 目标

	- 深入理解Entites
	- 发现问题域中的实体
	- Entites和Value Object的区别
	- 怎么创建具有表达性的实体

- 什么是Entities

	- 具有唯一标志和持久性的领域概念
	- 上下文相关

- 实现Entities

	- 分配唯一标志符号

		- 自然唯一健

			- 社保号
			- 国家名字
			- 工号
			- 身份证号码
			- 书号

		- 任意生成的ID

			- 自然递增
			- GUIDs或UUIDs

		- 字符串
		- 数据库生成的Id

	- 将行为放入值对象或领域服务中
	- 验证和强制不变
	- 专注于行为，而非数据
	- 避免“模拟现实世界”的谬论
	- 为分布式设计

- 常用实现模式

	- 用规范实现验证和不变

		- 规范

			- 小的，简单的类似法律的类

		- 好处

			- 实现单一职责原则
			- 提高测可测试性
			- 将行为从实体中脱离

	- 避免状态模式：使用明确的模型
	- 避免Getters和Setters ,使用快照传递出去
	- 函数明确，不要要副作用

### Domain Service 领域服务

- 目标

	- 深入理解领域服务
	- 掌握领域服务和其他服务的区别
	- 何时使用领域服务
	- 怎样将领域服务集成到应用层和领域模型中

- 什么是领域服务

	- 和领域相关的概念
	- 存在于问题域
	- 无状态
	- 表示行为
	- 没有唯一性标志
	- 协调多个Entites和领域对象

- 什么使用使用领域服务

	- 封装业务规则和处理过程
	- 代表协议

- 避免贫血模型

	- 不要在领域服务中放太多逻辑

- 和应用服务的区别

	- 实例

		- 认证和授权应该在应用服务处理，而非领域服务

- 实践

	- Http请求应该放在基础设施
	- 在服务层

		- 可以在应用服务层中调用
		- 可以将相关实体放入领域服务中

	- 在领域层

		- 借助领域服务完成任务
		- 手动 注入
		- 使用依赖注入
		- 使用服务定位
		- 使用双重委派
		- 使用领域事件解耦

### 领域事件

- 目标

	- 掌握领域事件设计模式
	- 实现领域事件模式
	- 使用领域事件测试应用

- 本质

	- 发布订阅模式
	- 什么是事件

		- 代表问题域中的发生的重要的事件的数据结构

	- 为事件做出响应
	- 可选异步

- 内部事件和外部事件

	- 内部事件

		- 只在上下文内部传递

	- 外部事件

		- 在不同上下文之间传递

- 处理事件

	- 调用领域逻辑
	- 调用应用逻辑

### Aggregates(聚合体）

- 目标

	- 怎样处理复杂领域实体和值对象之间的关系
	- 为什么聚合体是有效的战术模式
	- 怎样构建聚合体
	- 根聚合体的作用
	- 理解聚合一致性原则

- 管理复杂领域模型

	- 基于使用场景
	- 优先考虑单一方向
	- 谨慎判定领域之间的关系
	- 优先使用Id而非引用

- 聚合体

	- 目的：构建一致性边界
	- 围绕领域不变式设计

		- 领域不变：需要遵守的声明或规则

	- 领域的高度抽象
	- 一致性的边界

		- 内部事务一致性
		- 外部最终一致性
		- 特殊场景

	- 使用小的聚合体

		- 大的聚合体会影响性能
		- 大的聚合体更容易出现并发问题
		- 大的聚合体不利于扩展

	- 定义聚合体边界

		- 和不变式看齐
		- 和事务及一致性看齐
		- 忽略用户界面的影响
		- 避免收集笨蛋和容器
		- 不要只关注有什么关系

			- 聚合体不是数据结构

		- 重构成聚合体
		- 满足业务需求，而非模拟现实

	- 实现聚合体

		- 选择根聚合体

			- 聚合体的网关

		- 暴露行为接口
		- 保护内部状态

			- 不要暴露Getter和Setter

		- 只允许根聚合体和全局唯一标志
		- 重构其他聚合体

			- 使用Id引用其他聚合体

		- 集合体外部的任务事物都不能引用内部的任何事务
		- 持久化

			- 由根聚合体负责持久化和数据加载
			- 查询可以直接放在数据库层
			- 删除根聚合体时，相应数据也要删除
			- 避免懒加载

		- 事务一致性

			- 内部数据保存一致

		- 最终一致性

### Factories工厂

- 目标

	- 理解工厂如何将使用和构造分开
	- 在聚合体中使用工厂方法
	- 使用工厂方法重新构造对象
	- 工厂方法的使用场景

- 工厂的作用

	- 将对象构造和使用
	- 封装内部实现
	- 决定生产的对象类型

### Repositories 仓储

- 目标

	- 理解仓储的角色责任
	- 厘清对仓储模式的误解
	- 理解领域对象和持久化对象区别
	- 如何实现持久化

- 什么是仓储

	- 管理聚聚合体持久化和数据恢复
	- 领域对象和数据模型的桥梁
	- 只由根聚合体能调用仓储
	- 定义领域模型和数据模型的边界
	- 封装持久化细节，达到与具体持久化技术分离
	- 在基础设施成实现相应接口

- 常见误解

	- 不是反模式
	- 领域模型和持久化模型的区别：通过仓储隔离

		- ORM的作用

			- 抽象了关系数据模型
			- 持久化模型基于表和字段构成
			- 持久化数据结构

		- 领域模型

			- 对领域问题的抽象
			- 具有丰富行为

	- 通用仓储

		- 前提条件：所有聚合体都有相同的操作
		- 操作不明确

- 实现策略

	- 使用可以将领域模型映射到数据模型而不会降低性能的持久化框架
	- 必须要修改领域模型的持久化框架

		- 提供Getters和Setters
		- 使用备忘录模式

			- 领域模型自己生成快照

		- 事件流

	- 务实操作

		- 不要和框架作对
		- 根据实际情况修改领域模型

- 仓储式明确的协议

	- 不仅仅是CRUD接口
	- 领域专家也能理解的概念
	- 基于实际场景定义而不是数据的访问和修改
	- 名字要有意义

- 事务管理
- 保存还是不保存

	- 框架直接记录领域对象的变化
	- 需要明确保存聚合体的变化

- 将仓储作为反腐层
- 仓储层的其他作用

	- 为实体生成ID
	- 汇总摘要
	- 日志记录

- 仓储模式

	- 不支持临时查询
	- 不要使用延迟加载
	- 不要将仓储用于报告需求

### Event Sourcing(事件溯源)

- 目标

	- 理解什么是事件溯源
	- 事件溯源能解决什么问题
	- 怎样构建基于事件溯源的领域模型
	- 怎么构建Event Store 
	- 什么时候使用事件溯源

- 保存模型状态快照的缺点

	- 无法直到系统如何到达这个状态
	- 无法分析过去的行为

- 什么是事件溯源

	- 按时间记录每一个事件
	- 时间查询

		- 可以查询过去所有的状态

	- 预测
	- 快照

- 事件溯源聚合对象

	- 结构

		- 特点

			- 能够持久化到Event Store
			- 能够应用到领域事件并根据业务规则更新状态
			- 提供版本，创建快照并恢复事件

		- 添加事件溯源能力
		- 暴露具有表现力的领域关注的API
		- 支持快照

	- 持久化和事件恢复

		- 创建事件溯源仓储
		- 快照持久化和重新加载

	- 处理并发
	- 测试

		- 校验事件是否发生

- 构建Event Store

	- 设计存储格式
	- 创建事件流
	- 添加事件流
	- 查询事件流
	- 添加快照能力
	- 管理并发

## 有效应用的设计模式

## 

