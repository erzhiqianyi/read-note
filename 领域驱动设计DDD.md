# 领域驱动设计DDD

## 领域驱动设计的原则和实践

### 什么是领域驱动设计？

- 目标

	- 理解领域驱动设计

		- 原则
		- 实践
		- 模式

	- 分析问题空间的重要性
	- 维护软件的重要技能

		- 合作
		- 交流
		- 上下文

- 复杂领域问题带来的挑战

	- 大泥球架构的问题

		- 杂乱无序
		- 面条式的代码
		- 可以工作，但是不明所以

	- 软件复杂的原因

		- 代码实现和业务分析缺乏共同语言

			- 代码没有展现业务意图
			- 分析模型和最终代码没有保持一致

				- 实际操作上可能没有分析模型，得到需求后直接写代码

			- 代码难以阅读和维护

		- 缺乏组织

			- 混乱的代码影响项目进度
			- 容易产生bug

		- 问题域分析不足

			- 问题域是什么？

				- 软件要解决的问题
				- 业务专家和工程师的共识
				- 示例

					- 记录病人治疗的软件

						- 医疗行业专业术语
						- 不同部门如何看病人
						- 医生需要收集什么信息
						- 医生用这些信息做什么

			- 分析问题域为何能降低复杂度？

				- 领域驱动的战略模式，分割解决方案

					- 提炼问题域，找出问题的重点，拆分成更小的问题域
					- 创建模型解决领域问题
					- 使用共同语言完成建模协作
					- 消除模型中的歧义和问题
					- 区分上下文之间的关系

				- 领域驱动的战术模式，实现领域

					- 问题空间
					- 解决空间

- 设计原则和实践

	- 专注于主要领域

		- 软件的价值所在
		- 团队成员必须理解

	- 通过合作学习

		- 业务专家和开发人员互相学习

	- 通过探索和实验构建模型
	- 交流

		- 达成交流的基础：共同语言

	- 理解模型的适用范围
	- 持续改善模型

- 常见的错误观念

	- 战术模式是DDD的关键
	- DDD是一个框架
	- DDD是银弹

### 提炼问题域

- 目标

	- 掌握提炼问题域的方法

- 方法

	- 知识消化和交流

		- 角色

			- 从使用场景开始
			- 业务专家
			- 开发团队

		- 使用共同语言达成共识

			- 共同语言

				- 各方都能理解
				- 明确
				- 描述问题和编程实现时都能使用

		- 理解领域知识

			- 达到用简单术语描述问题

		- 重视业务分析
		- 持续提炼

	- 通过领域专家获得领域认实

		- 领域专家

			- 构建领域模型满足业务和程序的需求

		- 业务需求方

			- 注重需要需要实现得功能

		- 深入理解业务
		- 和领域专家互动

	- 对知识进行提炼压缩

		- 专注于有趣的部分
		- 从使用场景开始
		- 问有用的问题
		- 想法可视化

			- 使用简单图表
			- uml语言
			- 类职责交流卡片

				- 类名
				- 类职责
				- 关联的和实现其目的所需要的类

			- 定义模型名字

		- 行为驱动开发，BDD 

			- 专注于软件行为，软件需要做什么
			- Given
			- When
			- Then

		- 快速形成原型

	- 查看已经存在的模型

		- 理解意图

			- 深入理解用户需求，用户可能基于当前系统提出需求，而不是真正需求

		- 活动风暴

			- 帮助快速理解领域问题
			- 开发团队：提问题
			- 领域专家：回答问题

		- 影响映射，分析需求带来的影响

			- 从整体考虑需求带来的影响

				- 业绩收益
				- 系统影响

			- 提出自己的想法和建议

		- 理解业务模型

			- 使用业务模型卡片：Business Model Canvas

### 专注于主要领域

- 目标

	- 理解拆分领域问题的重要性
	- 如何找出并专注于核心领域
	- 如何实现通用领域
	- 合理设计的重要性，区分主次

- 问题

	- 为什么问题域会变糟糕？

		- 系统越大，越复杂，不是所有功能都一样重要

- 如何找出核心领域

	- 什么是核心领域

		- 系统最有价值的部分

	- 从长远的角度看需求

	  用户会想要一匹更快的马

	- 分析领域问题时尽量不要考虑技术细节
	- 拆分领域问题

		- 核心领域

			- 哪一部分决定产品的成败
			- 把核心领域当初产品

		- 通用领域

			- 通用业务的领域

				- 发送邮件服务

		- 支持领域

			- 支持核心领域

- 通过子领域合作形成解决方案
- 不是所有领域都同等重要

	- 区分领域边界
	- 核心领域不一定一开始就达到完美
	- 新建领域而不要尝试代替遗留领域

### 模型驱动设计

- 目标

	- 什么是领域模型
	- 理解通用语言的重要性
	- 如何用通用语言改善沟通和协作
	- 正确的应用来领域驱动设计
	- 如果创建有效的模型
	- 使用通用语言绑定分析模型和代码模型

- 领域模型

	- 领域和领域模型的区别

		- 领域

			- 需要解决的问题
			- 现实问题

		- 领域模型

			- 问题域的抽象
			- 用视图表示的代码实现
			- 帮助解决当前问题
			- 不涉及技术细节

	- 分析模型

		- 描述系统模型的集合
		- 帮助理解问题领域
		- 不是技术实现的蓝图

	- 代码模型

		- 代码模型是领域模型的重要表达
		- 和业务同步

- 模型驱动设计

	- 将分析模型和代码实现绑定的过程
	- 注重实现
	- 前期设计的挑战

		- 代码实现和分析模型脱钩
		- 要求全团队进行合作
		- 团队信息要同步

	- 如何实现模型驱动设计

		- 使用通用语言绑定分析模型和代码模型
		- 基于通用语言交流合作

			- 开发人员

				- 技术抽象
				- 设计模式
				- 设计原则
				- 考虑领域术语和概念

			- 领域专家

				- 业务处理
				- 工作流

		- 通过示例来优化通用语言
		- 让领域专家专注于问题而非提供解决方案
		- 优化通用语言

			- 确保语言一致，领域专家和开发人员都能理解
			- 和领域专家确术语表
			- 维持同一个事务只有一个术语
			- 尽量避免通用词语

				- service
				- manager
				- policy

			- 尽量避免使用技术领域专业术语

				- 设计模式

			- 良好的命名
			- 根据通用语言命名例外
			- 通用语言要有语义性

	- 什么时候使用模型驱动设计

		- 简单问题可以不用模型化
		- 专注于核心问题

	- 如何高效创建领域模型

		- 专注于核心领域

			- 模型数据结构
			- 有什么操作

		- 不要让真相成为榜样

			- 领域模型是对现实的抽象而非镜像

		- 仅为相关内容建模
		- 模型只是为当时需求建模，与业务保持同步
		- 明确专用术语
		- 合理抽象

			- 通过领域即可理解领域概念，不必深入代码
			- 抽象行为不是实现

		- 尽早用代码实现模型
		- 尽可能想更多实现方案

### 领域模型实现模式

- 目标

	- 理解领域层的作用
	- 掌握实现领域模型的模式
	- 如何选择正确的设计模式

- 领域层

	- 定义

		- 包含领域模型部分的代码

	- 特点

		- 讲领域模型的负责性和应用程序的技术复杂性隔离
		- 确保基础设施不会渗入业务问题

			- 基础设施

				- 事务管理
				- 持久化

	- 实现模式

		- 领域模型

			- 是对象

				- 行为
				- 数据

			- 前提条件

				- 没有数据库，不需要持久化

			- 从代码模型开始，而非数据模型

				- 和数据模型驱动相反

		- 交易脚本

			- 过程化
			- 适用于没有业务逻辑或业务逻辑较少

		- 表模型

			- 映射到数据库

		- 贫血模型

			- 领域对象仅仅是数据传输对象
			- 领域服务处理业务逻辑
			- 适用于没有业务逻辑或业务逻辑较少

### 通过上下文边界维护领域的完整性

- 目标

	- 理解单一模型带来的挑战
	- 理解上下文边界的重要性
	- 掌握找出上下文边界的方法
	- 保护合谐领域的完整性
	- 掌握使用上下文边界的条件

- 为什们要有上下文边界

	- 单一模型带来的挑战

		- 业务变更，模型会变得复杂
		- 多个团队共用一个模型
		- 模型语言带来歧义。同一术语在不同模型中意义可能不一样
		- 不同领域有不同的适用范围，单一模型职责太多

	- 区分模型边界，可降低复杂度
	- 领域模型不是企业模型

- 什么是上下分边界

	- 定义领域的适用范围

		- 领域用来做什么
		- 哪些范围需要保持一致
		- 哪些部分需要忽略

- 划分上下文边界

	- 根据技术划分
	- 根据业务划分
	- 影响上下文边界的因素

		- 领域中术语和概念的歧义
		- 与子领域和业务保持一致
		- 团队组织和物理位置
		- 遗留代码
		- 第三方集成

	- 方法

		- 定义语言边界

			- 与领域专家交谈时，确保上下文明确
			- 如果一个概念在同一个模型里有不同意义，考虑拆分成多个上下文

		- 与业务能力保持一致
		- 为团队创建上下文
		- 保持团队间的交流

- 子领域和上下文边界的区别

	- 子领域

		- 区分应用的重要部分
		- 提炼问题域，降低复杂度

	- 上下文边界

		- 用来实现模型边界的具体技术1
		- 存在于解决域

- 建议

	- 团队协作时，确保成员都明白领域上下文
	- 把上下分边界当作国界

### 映射上下文

- 目标

	- 理解上下文映射在战略设计中的重要性
	- 理解模型在上下文边界中的关系
	- 掌握团队及上下文之间的组织关系模式
	- 如何高效传递上下文映射

- 现实的映射

	- 特点

		- 确保系统各个上下文的边界定义清晰
		- 每个团队都能理解其中的关系
		- 不是详细的文档
		- 足够简单

	- 技术现实

		- 强调上下文之间的整合
		- 技术如何影响应用整合
		- 应用的当前状态
		- 各个上下文之间的联络点以及数据的流动
		- 和代码保持同步

	- 组织现实

		- 团队和团队，人和人之间的关系

- 识别有界上下文之间的关系

	- 反腐层

		- 什么是反腐层

			- 隔离层。类似适配器

				- 内部上下文
				- 中间接口
				- 外部上下文

		- 适用场景

			- 和其他系统通信
			- 本系统内不同领域或者有歧义的相同领域
			- 其他业务可能将现有模型腐化

	- 共享内核

		- 适用场景

			- 有相同的领域逻辑

				- 

	- 开放服务

		- 将共同逻辑做成开放接口，封装，供其他服务使用

	- 服务分开

		- 如果集成服务比较麻烦，可以将服务分开
		- 用户界面或手动流程进行整合

### 应用架构

- 目标

	- 应用架构如何保持领域模型的完整性
	- 应用架构有界上下文的区别
	- 应用服务的角色和职责
	- 如何支持多客户端

- 应用架构

	- 分清应用层序的层次

		- 将技术复杂度和领域复杂度分开
		- 展现UI
		- 持久化
		- 领域逻辑

	- 六边形架构

		- 
		- 底层定义接口，由上层实现

	- 依赖倒置

		- 

	- 领域层

		- 不依赖其他层

	- 应用服务层

		- 应用的使用场景和行为
		- 抽象程度高于领域层，粗粒度的抽象
		- 领域层的客户端
		- 集成其他资源，外部资源要适应接口

			- 从数据源恢复数据1
			- 持久化领域模型状态
			- 与系统其他部分通信

		- 可以作为反腐层

	- 基础设施层

		- 具体实现
		- 日志
		- 安全
		- 通知
		- 其他基础逻辑

	- 层之间的通信

		- 不要通过领域模型通信
		- 通过DTOS(data transfer objects)进行通信
		- 高层必须通过适应低层详消息类型来与底层进行通信

	- 测试分层

		- 可以通过mock其他依赖来进行测试

	- 不要在有界上下文之间共享数据结构

		- 有界上下文有自己独立的数据库

	- 和有界上下文的区别

		- 应用架构可以集成多个有界上下文

- 应用服务：将所有工作委托给该层

	- 只包含应用逻辑

		- 安全
		- 事务管理
		- 和其他服务通信

			- 邮件
			- web服务

	- 领域层客户端
	- 基于接口提供服务
	- 应用逻辑和领域逻辑的区别

		- 应用逻辑

			- 满足业务用例所需的工作流程步骤

				- 校验输入数据
				- 从数据库中得领域对象
				- 将数据转为领域层所需数据
				- 完成业务逻辑

			- 委派领域服务和协调基础设施服务
			- 不做业务逻辑，但是知道给谁做
			- 与技术实现无关

		- 领域逻辑

			- 只解决领域问题

	- 定义和公开功能

		- 客户端适配应用服务，而非应用服务适配客户端

	- 协调业务用例

		- 代表使用场景，而非增删改查

	- 领域层实现具体细节

- 客户端

	- 展现系统的能力
	- 服务应该忽略客户端的功能
	- 客户端要适配服务端Api

### 实践领域驱动设计常见问题

- 目标

	- 理解为什么领域驱动设计不仅仅是写代码
	- 避免过分强调战术模式
	- 为什么错误使用领域驱动设计会让问题变复杂
	- 理解战术设计，合作及交流的重要性
	- 明白专注于核心领域的重要性
	- 理解领域专家的重要性
	- 避免领域驱动设计中的反模式

- 领域驱动设计适用场景

	- 适用于复杂的问题

- 过分强调战术重要性的问题

	- 技术人员专注于写代码忽略业务
	- 所有有界上下分都使用同样的架构
	- 追求战术模式的完美
	- 错把基础构建模块当作DDD的价值，忽略其他部分
	- 专注于代码而不DDD的原则

- 忽略DDD重要的部分：合作，交流以及上下文

	- 低估上下文的重要性
	- 不创建UL导致歧义和误解
	- 缺乏合作设计出依赖技术的解决方案

- 花太多时间在不重要的部分
- 简单问题复杂化

	- 将领域驱动设计应用于琐碎的领域，几乎没有业务期望
	- 忽略crud作为反模式，简单问题可以直接crud
	- 将领域模型模式应用岛所有上下文中

- 应用领域驱动设计的代价

	- 资源
	- 时间

### 应用领域驱动设计原则，实践和模式

- 目标

	- 怎样推销领域驱动设计
	- 将领域驱动设计原则和实践应用到项目中
	- 理解探索和实验在寻找有用模型中的作用
	- 为什么避免歧义能有效提高建模的效率
	- 解决问题时消除技术的复杂性
	- 为什么不需要当心完美的领域模型
	- 怎样知道自己时在做正确的事

- 推销领域驱动设计

	- 团队要求

		- 渴望学习
		- 积极充满激情
		- 熟练
		- 有领域专家

	- 业务要求

		- 复杂且不平凡的业务

	- 方法要求

		- 持续迭代

	- 培养团队

		- 技术不是解决方案，而不是实现细节
		- 解决问题是通过和领域专家合作产生有用模型

	- 和业务需求方交流

- 应用领域驱动设计原则

	- 从简单问题开始，直到熟练
	- 理解愿景

		- 产品的商业目的
		- 产品会带来什么价值
		- 产品为什么会成功
		- 和之前存在的产品有什么区别

	- 捕获所需行为

		- 应用行为驱动设计
		- 需要的行为

			- 使用场景
			- 输入
			- 输出

		- 为什么需要这些行为，什么时候需要
		- 提炼问题空间
		- 专注于重要部分

	- 了解项目的真是性

		- 进行上下文映射
		- 找出受问题域影响模型

			- 画出它们的上下文
			- 为它们命名
			- 谁该为它们负责

		- 绘制集成点和集成方法
		- 映射交换的数据和拥有者
		- 标记出上下文之间的关系
		- 重复上面步骤，直到完全理解

	- 模型化解决方案

		- 前提要求

			- 领域是否足够复杂或者有复杂的子领域
			- 对业务是否重要且有高期待
			- 是否有领域专家参与
			- 团队充满激情并且聪明

		- 不是所有问题都一样重要
		- 吸引领域专家参与
		- 根据具体方案选择行为和模型
		- 和领域专家在最有趣的部分合作
		- 用UL解决歧义
		- 扔掉第一个和第二个模型
		- 在代码中实现模型
		- 创建领域模型

			- 迭代过程
			- 和领域问题相关：解决领域问题
			- 富有表达力：自解释性

				- 为什么这么做
				- 在做什么

		- 保持代码简单，普通
		- 开拓安全领域

			- 处理遗留代码时，将遗留代码隔离

		- 尽快尽早集成模型
		- 非技术层面的重构
		- 分解解决域

	- 探索和实验

		- 改变假设
		- 建模是一个持续的过程
		- 没有错误的模型
		- 发现辅组代码

- 让不明确的变得明确

	- 处理歧义
	- 为事物命名

- 首先解决问题，其次才是技术实现

	- 不要尝试解决所有问题

## 通过战略模式在上下文之间交流

### 集成有界上下文

- 目标

	- 如何在分布式系统中集成有界上下文
	- 构建分布式系统的基本挑战
	- 理解面向服务架构如何帮助构建低耦合的有界上下文和独立团队
	- 通过响应式DDD来实现非技术性需求

- 怎样集成有界上下文

	- 有界上下文是独立的，应该互不影响
	- 在代码层面上集成有界上下文的挑战

		- 解决方案中存在多个有界上下文
		- 通过命名空间或项目

			- 一个项目的改动会影响到其他项目

		- 通过数据库集成

			- 共享数据结构，改变数据结构会改变持有该结构的上下文
			- 容易产生歧义
			- 破环单一职责原则

		- 多个团队在一个代码库上工作

			- 影响协作

		- 模糊模型

			- 依赖混乱
			- 耦合度高

	- 使用物理隔离强制获得干净模型

		- 独立代码库
		- 独立数据库
		- 独立开发团队

	- 集成遗留系统

		- 使用气泡上下分隔离遗留项目

			- 遗留项目
			- 现有项目

		- 自主的气泡上下文

			- 有自己的数据源
			- 可以独立于遗留项目运行

		- 把遗留项目做成服务

- 集成分布式有界上下文

	- 策略

		- 更注重非功能性需求

	- 数据库集成
	- 水平文件集成
	- 远程过程调用(RPC)
	- 消息
	- REST服务

- 分布式系统执行领域驱动设计的挑战

	- RPC的问题

		- 难以做到有弹性

			- 网络请求不稳定

		- 扩展成本更高
		- 产生高耦合

			- 逻辑耦合
			- 时间耦合

	- 分布式事务影响扩展性和可靠性

		- 有界上下文没必要保持一致
		- 保持最终一致

- 事件驱动下反应式领域驱动设计

	- 消息驱动

### 通过消息集成

- 目标

	- 通过异步消息来集成有界上下文
	- 为领域中的重要事件设计和建筑消息系统
	- 理解消息框架如何工作
	- 创建架构示意图
	- 解释命令和事件的区别
	- 行业标准消息的第模式的理论和实例
	- 处理最终一致
	- 监控消息系统中的错误
	- 监控消息系统中的服务级别协议

- 消息基础

	- 消息总线

		- 所有组件都只和消息总线关联

	- 可靠的消息传递

		- 模式

			- 至少一次
			- 最多一次
			- 仅一次

	- 存储转发

		-  保证消息传输的可靠性

	- 指令和事件

		- 指令

			- 触发执行指定的事务
			- 发送方知道接收方如何处理
			- 只能被一个接收者处理

		- 事件

			- 发生了某事的信号
			- 发送方不知道接收方如何处理
			- 可以被多个接收者处理

	- 最终一致

- 实践：基因消息构建一个在线购物网站 

	- 系统设计

		- 领域驱动域设计
		- 组件示意图

			- 有界上下文的工作流程
			- 

		- 容器示意图

			- 应用如何组织
			- 技术选型
			- 通信协议
			- 

		- 架构演进

	- 通过web应用传递指令

		- 使用vue创建搭建前端

	- 处理指令和事件
	- 创建消息网关

		- 通过消息网关提供容错率
		- 控制消息重试

	- 保持最终一致

		- 处理不一致
		- 回滚倒新状态

	- 有界上下文只存储本地所需的数据
	- 通过UI集成所有

		- 业务组件需要他们自己的api

	- 建议

		- 内部有界上下文的通信使用消息
		- 和外部不稳定的通信使用消息网关包装，来提高可靠性
		- 不同上下文可以使用不同技术实现
		- 有界上下文之间不共享数据库

## 通过战术模式高效创建领域模型

## 有效应用的设计模式

## 

